Table PCB {
  pcb_id int pk
  process_name char(50)
  user_id char(20) // current user
  ppid int // pid du parent
  etat etat_enum // un des valeur aux etat-enum
  priorite int // 1 to 5
  /*
  normalement doit etre l adress du prochaine instruction 
  mais on va la stimuler avec un list des char,
  chaque char can either indicate to (use or dont use) ressource
  */
  compteur_programe list(char)
  memoire_necessaire float // memoire necessaire en mbit
  
  temps_necessaire float // (burst) temps necessaire pour l exec ; burst = compte_temps + temps_restant
  compte_temps float // temps cpu consomme en ms "initialise a burst decreasing bu schedular"
  temps_restant float // remaining time in ms
  cpu_usage int // *importante* need cpu_logs in every instruct we log wich process did it and we sum process divide by total

  temps_arrive time // quand il etait ajouté au process_table
  temps_creation time // quand la structure etait creer
  temps_execution time // time total needed en ms -> burst time
  temps_fin time // when marked terminated

  temps_attente float // gap between temps arrive et temps exec
  tournround float // from temps arrive jusqua terminé

  pid_children list(int) // pointeur vers premier element du list des id des process chldren
  pid_siblings_next int // pointeur vers un next sibling block
  pid_siblings_previous int // pointeur vers previous sibling block
}

// pcb helper
enum etat_enum {
  "ready"
  "blocked"
  "execution"
  "terminated"
}

// should allocate all pcbs in memory then identify them
// store all the structures in a list store pointer to a variable ex: proc_table
Table process_table {
  pid int // l id affecté au pcb
  pic_id int [ref : > PCB.pcb_id] // l'id definie en pcb 
}


Table ready_queue_element {
  pid int // process id
  next pointer // pointeur vers next element (depens on schedular algorithm)
  previous pointer // pointeur vers l element precedent (depens also on the schedular alogorithm)
}
// ready_queue shouln't modify the process_list but clone the process table elements after sorting or depens on the schedular
Table ready_queue {
  head pointeur // pointe vers ready_queue_element created by ready_queue function
  tail pointeur // pointe vers ready_queue_element
  size int // n ready_queue_elements
}




































